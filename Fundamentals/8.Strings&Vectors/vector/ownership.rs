// Ownership ของชิ้นเดียว มีเจ้าของได้คนเดียว (ถ้าให้คนอื่นไปแล้ว เราจะหมดสิทธิ์ทันที)

// กรณีที่ 1 การเปลี่ยนมือ (Move)
// เหมือนคุณมี "บัตรคอนเสิร์ต" อยู่ 1 ใบ ถ้าคุณยื่นให้เพื่อน เพื่อนเข้างานได้ แต่คุณเข้าไม่ได้แล้ว

fn main() {
    // 1. คุณ (v1) ซื้อบัตรมา
    let v1 = vec![1, 2, 3]; 

    // 2. คุณยื่นบัตรให้เพื่อน (v2)
    // ใน Rust เรียกว่าการ "Move" (ย้ายความเป็นเจ้าของ)
    let v2 = v1; 

    // 3. เพื่อน (v2) ใช้บัตรได้ปกติ
    println!("เพื่อนถือบัตร: {:?}", v2);

    // 4. แต่ถ้าคุณ (v1) พยายามจะใช้บัตรบ้าง...
    // println!("ฉันจะเข้างาน: {:?}", v1); 
    // ^^^ บรรทัดนี้จะ ERROR ทันที! คอมไพเลอร์จะด่าว่า "v1 value borrowed here after move"
    // แปลว่า: "ให้เขาไปแล้ว คุณจะไม่สามารถใช้อีกได้!"
}


// กรณีที่ 2: การส่งให้ฟังก์ชัน (Function Argument)
// เหมือนคุณ "โยนเอกสารลงเครื่องทำลายเอกสาร" พอเครื่องทำงานเสร็จ เอกสารนั้นก็หายไปเลย

fn main() {
    let my_vec = vec![10, 20, 30]; // สร้าง Vector

    // เรียกฟังก์ชัน show_vec แล้วส่ง my_vec เข้าไป
    show_vec(my_vec); 
    // จังหวะนี้ my_vec ถูก "ย้าย" เข้าไปในฟังก์ชันแล้ว
    // พอฟังก์ชันจบ มันจะทำลาย my_vec ทิ้งทันที

    // ถ้ากลับมาเรียกใช้ตรงนี้...
    // println!("ขอดูอีกที: {:?}", my_vec); 
    // ^^^ ERROR! เพราะของถูกทำลายไปในฟังก์ชันแล้ว
}

// ฟังก์ชันรับของ
fn show_vec(v: Vec<i32>) {
    println!("ดูข้อมูล: {:?}", v);
    // จบปีกกา } ของฟังก์ชันนี้ -> ตัวแปร v (และข้อมูลข้างใน) จะถูกลบทิ้ง (Drop)
}


// Vector = เงินสด: ถ้าคุณยื่นแบงค์พันให้คนอื่น (หรือให้ฟังก์ชัน) เงินจะหลุดจากมือคุณทันที

//Move = ตัดขาด: การเอาตัวแปรไปใส่ตัวแปรอื่น (v2 = v1) คือการย้ายของ ไม่ใช่การก๊อปปี้

//ถ้าอยากเก็บไว้ใช้ต่อ: ต้องใช้คำสั่ง .clone() (ถ่ายเอกสาร) หรือส่งแบบยืม (& Reference) แทนครับ
